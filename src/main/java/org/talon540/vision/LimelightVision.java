package org.talon540.vision;

import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.util.sendable.SendableBuilder;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

public class LimelightVision extends SubsystemBase {
    public class LimelightData {
        public boolean targetInView;
        public double offsetX, offsetY, skew, area, latency, piplineID;

        LimelightData(
                boolean targetInView,
                double offsetX,
                double offsetY,
                double skew,
                double area,
                double latency,
                double piplineID) {
            this.targetInView = targetInView;
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.skew = skew;
            this.area = area;
            this.latency = latency;
            this.piplineID = piplineID;
        }

        LimelightData(LimelightVision limelightSubsystem) {
            this.targetInView = limelightSubsystem.getTargetFound();
            this.offsetX = limelightSubsystem.getTargetOffsetX();
            this.offsetY = limelightSubsystem.getTargetOffsetY();
            this.skew = limelightSubsystem.getTargetSkew();
            this.area = limelightSubsystem.getTargetArea();
            this.latency = limelightSubsystem.getLatency();
            this.piplineID = limelightSubsystem.getPipeline();
        }

    }

    private volatile NetworkTable limelightTable;
    private double mountAngle, mountHeight;

    @Override
    public void periodic() {
        this.limelightTable = NetworkTableInstance.getDefault().getTable("limelight");
    }

    /**
     * Construct a limelight object
     * @param mountAngle mount angle of the limelight in degrees
     * @param mountHeight mount height of the limelight from the floor in meters
     */
    LimelightVision(double mountAngle, double mountHeight) {
        setName("limelight subsystem");
        this.mountAngle = mountAngle;
        this.mountHeight = mountHeight;

        this.limelightTable = NetworkTableInstance.getDefault().getTable("limelight");

        this.limelightTable.getEntry("pipeline").setNumber(0);
        this.limelightTable.getEntry("camMode").setNumber(0);

        // this.limelightTable.addEntryListener("tx", event -> {

        // }, EntryListenerFlags.kUpdate);
    }

    /**
     * Get all raw data from the limelight
     * @return all limelight data
     */
    public LimelightData getRawData() {
        return new LimelightData(this);
    }

    /**
     * Return whether a target is in the current POV
     * @return target in POV?
     */
    private boolean getTargetFound() {
        return this.limelightTable.getEntry("tv").getDouble(0) == 1;
    }

    /**
     * @return horizontal target offset from crosshair in degrees
     */
    private double getTargetOffsetX() {
        return this.limelightTable.getEntry("tx").getDouble(0);

    }

    /**
     * @return vertical target offset from crosshair in degrees
     */
    private double getTargetOffsetY() {
        return this.limelightTable.getEntry("ty").getDouble(0);

    }

    /**
     * @return area of target in pixels, useful for some distance calculations
     */
    private double getTargetArea() {
        return this.limelightTable.getEntry("ta").getDouble(0);
    }

    /**
     * @return target rotation or skew
     */
    private double getTargetSkew() {
        return this.limelightTable.getEntry("ts").getDouble(0);
    }

    /**
     * @return latency generated by just the pipeline for vision processing
     */
    private double getPipelineLatency() {
        return this.limelightTable.getEntry("tl").getDouble(0);
    }

    /**
     * @return total estimated latency
     */
    private double getLatency() {
        return getPipelineLatency() + 11.0;
    }

    /**
     * @return current pipeline used by the limelight [0,9]
     */
    private int getPipeline() {
        return (int) this.limelightTable.getEntry("getpipe").getDouble(0);
    }

    /**
     * Get distance from a specified target's base
     * @param targetHeight height of the retroreflector in meters
     * @return distance from the base of the target in meters
     */
    public double getDistanceFromTargetBase(double targetHeight) {
        double verticalOffset = Math.toRadians(this.getTargetOffsetY());
        double limelightAngle = Math.toRadians(this.mountAngle);

        return ((targetHeight-this.mountHeight) / (Math.tan((limelightAngle + verticalOffset))));
    }

    /**
     * Get distance from a specified target (Hypotenuse)
     * @param targetHeight height of the retroreflector in meters
     * @return distance from the target in meters
     */
    public double getDistanceFromTarget(double targetHeight) {
        double verticalOffset = Math.toRadians(this.getTargetOffsetY());
        double limelightAngle = Math.toRadians(this.mountAngle);

        return ((targetHeight-this.mountHeight) / (Math.sin((limelightAngle + verticalOffset))));
    }

    /**
     * Set the limelight's pipeline
     * 
     * @param piplineID pipline id within [0,9]
     */
    public void setPipeline(int piplineID) {
        if (0 <= piplineID && piplineID <= 9) {
            this.limelightTable.getEntry("pipeline").setNumber(piplineID);
        }
    }

    /**
     * This function sets the LEDS to off
     */
    public void disableLEDS() {
        this.setLEDS(LimelightLEDStates.OFF);
    }

    /**
     * This function sets the LED mode of the Limelight
     * 
     * @param dLedStates The state of the LEDS.
     */
    public void setLEDS(LimelightLEDStates dLedStates) {
        switch (dLedStates) {
            case ON:
                this.limelightTable.getEntry("ledMode").setNumber(3); // light on
                break;

            case OFF:
                this.limelightTable.getEntry("ledMode").setNumber(1); // light off
                break;

            case BLINK:
                this.limelightTable.getEntry("ledMode").setNumber(2); // light blinking
                break;

            case DEFAULT:
            default:
                this.limelightTable.getEntry("ledMode").setNumber(0); // as per pipeline mode (usually on)

        }
    }

    @Override
    public void initSendable(SendableBuilder builder) {
        builder.setSmartDashboardType("limelight");

        builder.addBooleanProperty("targetInView", this::getTargetFound, null);
        builder.addDoubleProperty("offsetX", this::getTargetOffsetX, null);
        builder.addDoubleProperty("offsetY", this::getTargetOffsetY, null);
        builder.addDoubleProperty("pipelineLatency", this::getPipelineLatency, null);
        builder.addDoubleProperty("pipeline", this::getPipeline, null);

    }
}
